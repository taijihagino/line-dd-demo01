"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteSessionCookie = exports.retrieveSessionCookie = exports.toSessionString = exports.persistSessionCookie = exports.withCookieLockAccess = exports.MAX_NUMBER_OF_LOCK_RETRIES = exports.LOCK_RETRY_DELAY = exports.SESSION_COOKIE_NAME = void 0;
var cookie_1 = require("../../browser/cookie");
var timer_1 = require("../../tools/timer");
var browserDetection_1 = require("../../tools/utils/browserDetection");
var timeUtils_1 = require("../../tools/utils/timeUtils");
var polyfills_1 = require("../../tools/utils/polyfills");
var objectUtils_1 = require("../../tools/utils/objectUtils");
var stringUtils_1 = require("../../tools/utils/stringUtils");
var sessionConstants_1 = require("./sessionConstants");
var SESSION_ENTRY_REGEXP = /^([a-z]+)=([a-z0-9-]+)$/;
var SESSION_ENTRY_SEPARATOR = '&';
exports.SESSION_COOKIE_NAME = '_dd_s';
// arbitrary values
exports.LOCK_RETRY_DELAY = 10;
exports.MAX_NUMBER_OF_LOCK_RETRIES = 100;
var bufferedOperations = [];
var ongoingOperations;
function withCookieLockAccess(operations, numberOfRetries) {
    var _a;
    if (numberOfRetries === void 0) { numberOfRetries = 0; }
    if (!ongoingOperations) {
        ongoingOperations = operations;
    }
    if (operations !== ongoingOperations) {
        bufferedOperations.push(operations);
        return;
    }
    if (numberOfRetries >= exports.MAX_NUMBER_OF_LOCK_RETRIES) {
        next();
        return;
    }
    var currentLock;
    var currentSession = retrieveSessionCookie();
    if (isCookieLockEnabled()) {
        // if someone has lock, retry later
        if (currentSession.lock) {
            retryLater(operations, numberOfRetries);
            return;
        }
        // acquire lock
        currentLock = (0, stringUtils_1.generateUUID)();
        currentSession.lock = currentLock;
        setSessionCookie(currentSession, operations.options);
        // if lock is not acquired, retry later
        currentSession = retrieveSessionCookie();
        if (currentSession.lock !== currentLock) {
            retryLater(operations, numberOfRetries);
            return;
        }
    }
    var processedSession = operations.process(currentSession);
    if (isCookieLockEnabled()) {
        // if lock corrupted after process, retry later
        currentSession = retrieveSessionCookie();
        if (currentSession.lock !== currentLock) {
            retryLater(operations, numberOfRetries);
            return;
        }
    }
    if (processedSession) {
        persistSessionCookie(processedSession, operations.options);
    }
    if (isCookieLockEnabled()) {
        // correctly handle lock around expiration would require to handle this case properly at several levels
        // since we don't have evidence of lock issues around expiration, let's just not do the corruption check for it
        if (!(processedSession && isExpiredState(processedSession))) {
            // if lock corrupted after persist, retry later
            currentSession = retrieveSessionCookie();
            if (currentSession.lock !== currentLock) {
                retryLater(operations, numberOfRetries);
                return;
            }
            delete currentSession.lock;
            setSessionCookie(currentSession, operations.options);
            processedSession = currentSession;
        }
    }
    // call after even if session is not persisted in order to perform operations on
    // up-to-date cookie value, the value could have been modified by another tab
    (_a = operations.after) === null || _a === void 0 ? void 0 : _a.call(operations, processedSession || currentSession);
    next();
}
exports.withCookieLockAccess = withCookieLockAccess;
/**
 * Cookie lock strategy allows mitigating issues due to concurrent access to cookie.
 * This issue concerns only chromium browsers and enabling this on firefox increase cookie write failures.
 */
function isCookieLockEnabled() {
    return (0, browserDetection_1.isChromium)();
}
function retryLater(operations, currentNumberOfRetries) {
    (0, timer_1.setTimeout)(function () {
        withCookieLockAccess(operations, currentNumberOfRetries + 1);
    }, exports.LOCK_RETRY_DELAY);
}
function next() {
    ongoingOperations = undefined;
    var nextOperations = bufferedOperations.shift();
    if (nextOperations) {
        withCookieLockAccess(nextOperations);
    }
}
function persistSessionCookie(session, options) {
    if (isExpiredState(session)) {
        deleteSessionCookie(options);
        return;
    }
    session.expire = String((0, timeUtils_1.dateNow)() + sessionConstants_1.SESSION_EXPIRATION_DELAY);
    setSessionCookie(session, options);
}
exports.persistSessionCookie = persistSessionCookie;
function setSessionCookie(session, options) {
    (0, cookie_1.setCookie)(exports.SESSION_COOKIE_NAME, toSessionString(session), sessionConstants_1.SESSION_EXPIRATION_DELAY, options);
}
function toSessionString(session) {
    return (0, polyfills_1.objectEntries)(session)
        .map(function (_a) {
        var key = _a[0], value = _a[1];
        return "".concat(key, "=").concat(value);
    })
        .join(SESSION_ENTRY_SEPARATOR);
}
exports.toSessionString = toSessionString;
function retrieveSessionCookie() {
    var sessionString = (0, cookie_1.getCookie)(exports.SESSION_COOKIE_NAME);
    var session = {};
    if (isValidSessionString(sessionString)) {
        sessionString.split(SESSION_ENTRY_SEPARATOR).forEach(function (entry) {
            var matches = SESSION_ENTRY_REGEXP.exec(entry);
            if (matches !== null) {
                var key = matches[1], value = matches[2];
                session[key] = value;
            }
        });
    }
    return session;
}
exports.retrieveSessionCookie = retrieveSessionCookie;
function deleteSessionCookie(options) {
    (0, cookie_1.deleteCookie)(exports.SESSION_COOKIE_NAME, options);
}
exports.deleteSessionCookie = deleteSessionCookie;
function isValidSessionString(sessionString) {
    return (sessionString !== undefined &&
        (sessionString.indexOf(SESSION_ENTRY_SEPARATOR) !== -1 || SESSION_ENTRY_REGEXP.test(sessionString)));
}
function isExpiredState(session) {
    return (0, objectUtils_1.isEmptyObject)(session);
}
//# sourceMappingURL=sessionCookieStore.js.map