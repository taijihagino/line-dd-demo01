import { instrumentSetter, assign, addEventListeners, forEach } from '@datadog/browser-core';
import { NodePrivacyLevel } from '../../../constants';
import { getEventTarget } from '../eventsUtils';
import { getNodePrivacyLevel, shouldMaskNode } from '../privacy';
import { getElementInputValue, getSerializedNodeId, hasSerializedNode } from '../serialization';
export function initInputObserver(cb, defaultPrivacyLevel, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.domEvents, domEvents = _c === void 0 ? ["input" /* DOM_EVENT.INPUT */, "change" /* DOM_EVENT.CHANGE */] : _c, _d = _b.target, target = _d === void 0 ? document : _d;
    var lastInputStateMap = new WeakMap();
    function onElementChange(target) {
        var nodePrivacyLevel = getNodePrivacyLevel(target, defaultPrivacyLevel);
        if (nodePrivacyLevel === NodePrivacyLevel.HIDDEN) {
            return;
        }
        var type = target.type;
        var inputState;
        if (type === 'radio' || type === 'checkbox') {
            if (shouldMaskNode(target, nodePrivacyLevel)) {
                return;
            }
            inputState = { isChecked: target.checked };
        }
        else {
            var value = getElementInputValue(target, nodePrivacyLevel);
            if (value === undefined) {
                return;
            }
            inputState = { text: value };
        }
        // Can be multiple changes on the same node within the same batched mutation observation.
        cbWithDedup(target, inputState);
        // If a radio was checked, other radios with the same name attribute will be unchecked.
        var name = target.name;
        if (type === 'radio' && name && target.checked) {
            forEach(document.querySelectorAll("input[type=\"radio\"][name=\"".concat(name, "\"]")), function (el) {
                if (el !== target) {
                    // TODO: Consider the privacy implications for various differing input privacy levels
                    cbWithDedup(el, { isChecked: false });
                }
            });
        }
    }
    /**
     * There can be multiple changes on the same node within the same batched mutation observation.
     */
    function cbWithDedup(target, inputState) {
        if (!hasSerializedNode(target)) {
            return;
        }
        var lastInputState = lastInputStateMap.get(target);
        if (!lastInputState ||
            lastInputState.text !== inputState.text ||
            lastInputState.isChecked !== inputState.isChecked) {
            lastInputStateMap.set(target, inputState);
            cb(assign({
                id: getSerializedNodeId(target),
            }, inputState));
        }
    }
    var stopEventListeners = addEventListeners(target, domEvents, function (event) {
        var target = getEventTarget(event);
        if (target instanceof HTMLInputElement ||
            target instanceof HTMLTextAreaElement ||
            target instanceof HTMLSelectElement) {
            onElementChange(target);
        }
    }, {
        capture: true,
        passive: true,
    }).stop;
    var instrumentationStoppers = [
        instrumentSetter(HTMLInputElement.prototype, 'value', onElementChange),
        instrumentSetter(HTMLInputElement.prototype, 'checked', onElementChange),
        instrumentSetter(HTMLSelectElement.prototype, 'value', onElementChange),
        instrumentSetter(HTMLTextAreaElement.prototype, 'value', onElementChange),
        instrumentSetter(HTMLSelectElement.prototype, 'selectedIndex', onElementChange),
    ];
    return function () {
        instrumentationStoppers.forEach(function (stopper) { return stopper.stop(); });
        stopEventListeners();
    };
}
//# sourceMappingURL=inputObserver.js.map